// Code generated by sqlc-gen-ts-d1. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
//   sqlc-gen-ts-d1 v0.0.0-a@dfd4bfef4736967ca17cc23d18de20920fbd196998fe7aa191a205439d63fb58

import {
	D1Database,
	D1PreparedStatement,
	D1Result,
} from "@cloudflare/workers-types/experimental";

type Query<T> = {
	then(
		onFulfilled?: (value: T) => void,
		onRejected?: (reason?: any) => void,
	): void;
	batch(): D1PreparedStatement;
};
const createCollectionQuery = `-- name: CreateCollection :one
INSERT INTO collections (slug, label, description, access, default_sort, list_searchable_fields, pagination, default_limit, max_limit)
VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9)
RETURNING id, slug, label, description, created_at, updated_at, access, default_sort, list_searchable_fields, pagination, default_limit, max_limit`;

export type CreateCollectionParams = {
	slug: number | string;
	label: number | string;
	description: string | null;
	access: number | string | null;
	defaultSort: number | string | null;
	listSearchableFields: number | string | null;
	pagination: number | string | null;
	defaultLimit: number | null;
	maxLimit: number | null;
};

export type CreateCollectionRow = {
	id: number;
	slug: number | string;
	label: number | string;
	description: string | null;
	createdAt: number | string | null;
	updatedAt: number | string | null;
	access: number | string | null;
	defaultSort: number | string | null;
	listSearchableFields: number | string | null;
	pagination: number | string | null;
	defaultLimit: number | null;
	maxLimit: number | null;
};

type RawCreateCollectionRow = {
	id: number;
	slug: number | string;
	label: number | string;
	description: string | null;
	created_at: number | string | null;
	updated_at: number | string | null;
	access: number | string | null;
	default_sort: number | string | null;
	list_searchable_fields: number | string | null;
	pagination: number | string | null;
	default_limit: number | null;
	max_limit: number | null;
};

export function createCollection(
	d1: D1Database,
	args: CreateCollectionParams,
): Query<CreateCollectionRow | null> {
	const ps = d1
		.prepare(createCollectionQuery)
		.bind(
			args.slug,
			args.label,
			args.description,
			args.access,
			args.defaultSort,
			args.listSearchableFields,
			args.pagination,
			args.defaultLimit,
			args.maxLimit,
		);
	return {
		then(
			onFulfilled?: (value: CreateCollectionRow | null) => void,
			onRejected?: (reason?: any) => void,
		) {
			ps.first<RawCreateCollectionRow | null>()
				.then((raw: RawCreateCollectionRow | null) =>
					raw
						? {
								id: raw.id,
								slug: raw.slug,
								label: raw.label,
								description: raw.description,
								createdAt: raw.created_at,
								updatedAt: raw.updated_at,
								access: raw.access,
								defaultSort: raw.default_sort,
								listSearchableFields: raw.list_searchable_fields,
								pagination: raw.pagination,
								defaultLimit: raw.default_limit,
								maxLimit: raw.max_limit,
							}
						: null,
				)
				.then(onFulfilled)
				.catch(onRejected);
		},
		batch() {
			return ps;
		},
	};
}

const getCollectionQuery = `-- name: GetCollection :one
SELECT id, slug, label, description, created_at, updated_at, access, default_sort, list_searchable_fields, pagination, default_limit, max_limit FROM collections WHERE id = ?1 LIMIT 1`;

export type GetCollectionParams = {
	id: number;
};

export type GetCollectionRow = {
	id: number;
	slug: number | string;
	label: number | string;
	description: string | null;
	createdAt: number | string | null;
	updatedAt: number | string | null;
	access: number | string | null;
	defaultSort: number | string | null;
	listSearchableFields: number | string | null;
	pagination: number | string | null;
	defaultLimit: number | null;
	maxLimit: number | null;
};

type RawGetCollectionRow = {
	id: number;
	slug: number | string;
	label: number | string;
	description: string | null;
	created_at: number | string | null;
	updated_at: number | string | null;
	access: number | string | null;
	default_sort: number | string | null;
	list_searchable_fields: number | string | null;
	pagination: number | string | null;
	default_limit: number | null;
	max_limit: number | null;
};

export function getCollection(
	d1: D1Database,
	args: GetCollectionParams,
): Query<GetCollectionRow | null> {
	const ps = d1.prepare(getCollectionQuery).bind(args.id);
	return {
		then(
			onFulfilled?: (value: GetCollectionRow | null) => void,
			onRejected?: (reason?: any) => void,
		) {
			ps.first<RawGetCollectionRow | null>()
				.then((raw: RawGetCollectionRow | null) =>
					raw
						? {
								id: raw.id,
								slug: raw.slug,
								label: raw.label,
								description: raw.description,
								createdAt: raw.created_at,
								updatedAt: raw.updated_at,
								access: raw.access,
								defaultSort: raw.default_sort,
								listSearchableFields: raw.list_searchable_fields,
								pagination: raw.pagination,
								defaultLimit: raw.default_limit,
								maxLimit: raw.max_limit,
							}
						: null,
				)
				.then(onFulfilled)
				.catch(onRejected);
		},
		batch() {
			return ps;
		},
	};
}

const getCollectionBySlugQuery = `-- name: GetCollectionBySlug :one
SELECT id, slug, label, description, created_at, updated_at, access, default_sort, list_searchable_fields, pagination, default_limit, max_limit FROM collections WHERE slug = ?1 LIMIT 1`;

export type GetCollectionBySlugParams = {
	slug: number | string;
};

export type GetCollectionBySlugRow = {
	id: number;
	slug: number | string;
	label: number | string;
	description: string | null;
	createdAt: number | string | null;
	updatedAt: number | string | null;
	access: number | string | null;
	defaultSort: number | string | null;
	listSearchableFields: number | string | null;
	pagination: number | string | null;
	defaultLimit: number | null;
	maxLimit: number | null;
};

type RawGetCollectionBySlugRow = {
	id: number;
	slug: number | string;
	label: number | string;
	description: string | null;
	created_at: number | string | null;
	updated_at: number | string | null;
	access: number | string | null;
	default_sort: number | string | null;
	list_searchable_fields: number | string | null;
	pagination: number | string | null;
	default_limit: number | null;
	max_limit: number | null;
};

export function getCollectionBySlug(
	d1: D1Database,
	args: GetCollectionBySlugParams,
): Query<GetCollectionBySlugRow | null> {
	const ps = d1.prepare(getCollectionBySlugQuery).bind(args.slug);
	return {
		then(
			onFulfilled?: (value: GetCollectionBySlugRow | null) => void,
			onRejected?: (reason?: any) => void,
		) {
			ps.first<RawGetCollectionBySlugRow | null>()
				.then((raw: RawGetCollectionBySlugRow | null) =>
					raw
						? {
								id: raw.id,
								slug: raw.slug,
								label: raw.label,
								description: raw.description,
								createdAt: raw.created_at,
								updatedAt: raw.updated_at,
								access: raw.access,
								defaultSort: raw.default_sort,
								listSearchableFields: raw.list_searchable_fields,
								pagination: raw.pagination,
								defaultLimit: raw.default_limit,
								maxLimit: raw.max_limit,
							}
						: null,
				)
				.then(onFulfilled)
				.catch(onRejected);
		},
		batch() {
			return ps;
		},
	};
}

const updateCollectionQuery = `-- name: UpdateCollection :one
UPDATE collections
SET slug = COALESCE(?1, slug),
    label = COALESCE(?2, label),
    description = COALESCE(?3, description),
    access = COALESCE(?4, access),
    default_sort = COALESCE(?5, default_sort),
    list_searchable_fields = COALESCE(?6, list_searchable_fields),
    pagination = COALESCE(?7, pagination),
    default_limit = COALESCE(?8, default_limit),
    max_limit = COALESCE(?9, max_limit),
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?10
RETURNING id, slug, label, description, created_at, updated_at, access, default_sort, list_searchable_fields, pagination, default_limit, max_limit`;

export type UpdateCollectionParams = {
	slug: number | string;
	label: number | string;
	description: string | null;
	access: number | string | null;
	defaultSort: number | string | null;
	listSearchableFields: number | string | null;
	pagination: number | string | null;
	defaultLimit: number | null;
	maxLimit: number | null;
	id: number;
};

export type UpdateCollectionRow = {
	id: number;
	slug: number | string;
	label: number | string;
	description: string | null;
	createdAt: number | string | null;
	updatedAt: number | string | null;
	access: number | string | null;
	defaultSort: number | string | null;
	listSearchableFields: number | string | null;
	pagination: number | string | null;
	defaultLimit: number | null;
	maxLimit: number | null;
};

type RawUpdateCollectionRow = {
	id: number;
	slug: number | string;
	label: number | string;
	description: string | null;
	created_at: number | string | null;
	updated_at: number | string | null;
	access: number | string | null;
	default_sort: number | string | null;
	list_searchable_fields: number | string | null;
	pagination: number | string | null;
	default_limit: number | null;
	max_limit: number | null;
};

export function updateCollection(
	d1: D1Database,
	args: UpdateCollectionParams,
): Query<UpdateCollectionRow | null> {
	const ps = d1
		.prepare(updateCollectionQuery)
		.bind(
			args.slug,
			args.label,
			args.description,
			args.access,
			args.defaultSort,
			args.listSearchableFields,
			args.pagination,
			args.defaultLimit,
			args.maxLimit,
			args.id,
		);
	return {
		then(
			onFulfilled?: (value: UpdateCollectionRow | null) => void,
			onRejected?: (reason?: any) => void,
		) {
			ps.first<RawUpdateCollectionRow | null>()
				.then((raw: RawUpdateCollectionRow | null) =>
					raw
						? {
								id: raw.id,
								slug: raw.slug,
								label: raw.label,
								description: raw.description,
								createdAt: raw.created_at,
								updatedAt: raw.updated_at,
								access: raw.access,
								defaultSort: raw.default_sort,
								listSearchableFields: raw.list_searchable_fields,
								pagination: raw.pagination,
								defaultLimit: raw.default_limit,
								maxLimit: raw.max_limit,
							}
						: null,
				)
				.then(onFulfilled)
				.catch(onRejected);
		},
		batch() {
			return ps;
		},
	};
}

const deleteCollectionQuery = `-- name: DeleteCollection :exec
DELETE FROM collections WHERE id = ?1`;

export type DeleteCollectionParams = {
	id: number;
};

export function deleteCollection(
	d1: D1Database,
	args: DeleteCollectionParams,
): Query<D1Result> {
	const ps = d1.prepare(deleteCollectionQuery).bind(args.id);
	return {
		then(
			onFulfilled?: (value: D1Result) => void,
			onRejected?: (reason?: any) => void,
		) {
			ps.run().then(onFulfilled).catch(onRejected);
		},
		batch() {
			return ps;
		},
	};
}

const listCollectionsQuery = `-- name: ListCollections :many
SELECT id, slug, label, description, created_at, updated_at, access, default_sort, list_searchable_fields, pagination, default_limit, max_limit FROM collections`;

export type ListCollectionsRow = {
	id: number;
	slug: number | string;
	label: number | string;
	description: string | null;
	createdAt: number | string | null;
	updatedAt: number | string | null;
	access: number | string | null;
	defaultSort: number | string | null;
	listSearchableFields: number | string | null;
	pagination: number | string | null;
	defaultLimit: number | null;
	maxLimit: number | null;
};

type RawListCollectionsRow = {
	id: number;
	slug: number | string;
	label: number | string;
	description: string | null;
	created_at: number | string | null;
	updated_at: number | string | null;
	access: number | string | null;
	default_sort: number | string | null;
	list_searchable_fields: number | string | null;
	pagination: number | string | null;
	default_limit: number | null;
	max_limit: number | null;
};

export function listCollections(
	d1: D1Database,
): Query<D1Result<ListCollectionsRow>> {
	const ps = d1.prepare(listCollectionsQuery);
	return {
		then(
			onFulfilled?: (value: D1Result<ListCollectionsRow>) => void,
			onRejected?: (reason?: any) => void,
		) {
			ps.all<RawListCollectionsRow>()
				.then((r: D1Result<RawListCollectionsRow>) => {
					return {
						...r,
						results: r.results.map((raw: RawListCollectionsRow) => {
							return {
								id: raw.id,
								slug: raw.slug,
								label: raw.label,
								description: raw.description,
								createdAt: raw.created_at,
								updatedAt: raw.updated_at,
								access: raw.access,
								defaultSort: raw.default_sort,
								listSearchableFields: raw.list_searchable_fields,
								pagination: raw.pagination,
								defaultLimit: raw.default_limit,
								maxLimit: raw.max_limit,
							};
						}),
					};
				})
				.then(onFulfilled)
				.catch(onRejected);
		},
		batch() {
			return ps;
		},
	};
}

const countCollectionsQuery = `-- name: CountCollections :one
SELECT COUNT(id) AS count FROM collections`;

export type CountCollectionsRow = {
	count: number;
};

export function countCollections(
	d1: D1Database,
): Query<CountCollectionsRow | null> {
	const ps = d1.prepare(countCollectionsQuery);
	return {
		then(
			onFulfilled?: (value: CountCollectionsRow | null) => void,
			onRejected?: (reason?: any) => void,
		) {
			ps.first<CountCollectionsRow | null>()
				.then(onFulfilled)
				.catch(onRejected);
		},
		batch() {
			return ps;
		},
	};
}

const createFieldValueQuery = `-- name: CreateFieldValue :one
INSERT INTO field_values (item_id, field_id, value)
VALUES (?1, ?2, ?3)
RETURNING id, item_id, field_id, value, created_at, updated_at`;

export type CreateFieldValueParams = {
	itemId: number | null;
	fieldId: number | null;
	value: string | null;
};

export type CreateFieldValueRow = {
	id: number;
	itemId: number | null;
	fieldId: number | null;
	value: string | null;
	createdAt: number | string | null;
	updatedAt: number | string | null;
};

type RawCreateFieldValueRow = {
	id: number;
	item_id: number | null;
	field_id: number | null;
	value: string | null;
	created_at: number | string | null;
	updated_at: number | string | null;
};

export function createFieldValue(
	d1: D1Database,
	args: CreateFieldValueParams,
): Query<CreateFieldValueRow | null> {
	const ps = d1
		.prepare(createFieldValueQuery)
		.bind(args.itemId, args.fieldId, args.value);
	return {
		then(
			onFulfilled?: (value: CreateFieldValueRow | null) => void,
			onRejected?: (reason?: any) => void,
		) {
			ps.first<RawCreateFieldValueRow | null>()
				.then((raw: RawCreateFieldValueRow | null) =>
					raw
						? {
								id: raw.id,
								itemId: raw.item_id,
								fieldId: raw.field_id,
								value: raw.value,
								createdAt: raw.created_at,
								updatedAt: raw.updated_at,
							}
						: null,
				)
				.then(onFulfilled)
				.catch(onRejected);
		},
		batch() {
			return ps;
		},
	};
}

const getFieldValueQuery = `-- name: GetFieldValue :one
SELECT id, item_id, field_id, value, created_at, updated_at
FROM field_values
WHERE id = ?1 LIMIT 1`;

export type GetFieldValueParams = {
	id: number;
};

export type GetFieldValueRow = {
	id: number;
	itemId: number | null;
	fieldId: number | null;
	value: string | null;
	createdAt: number | string | null;
	updatedAt: number | string | null;
};

type RawGetFieldValueRow = {
	id: number;
	item_id: number | null;
	field_id: number | null;
	value: string | null;
	created_at: number | string | null;
	updated_at: number | string | null;
};

export function getFieldValue(
	d1: D1Database,
	args: GetFieldValueParams,
): Query<GetFieldValueRow | null> {
	const ps = d1.prepare(getFieldValueQuery).bind(args.id);
	return {
		then(
			onFulfilled?: (value: GetFieldValueRow | null) => void,
			onRejected?: (reason?: any) => void,
		) {
			ps.first<RawGetFieldValueRow | null>()
				.then((raw: RawGetFieldValueRow | null) =>
					raw
						? {
								id: raw.id,
								itemId: raw.item_id,
								fieldId: raw.field_id,
								value: raw.value,
								createdAt: raw.created_at,
								updatedAt: raw.updated_at,
							}
						: null,
				)
				.then(onFulfilled)
				.catch(onRejected);
		},
		batch() {
			return ps;
		},
	};
}

const listFieldValuesQuery = `-- name: ListFieldValues :many
SELECT id, item_id, field_id, value, created_at, updated_at
FROM field_values
WHERE item_id = ?1
ORDER BY id`;

export type ListFieldValuesParams = {
	itemId: number | null;
};

export type ListFieldValuesRow = {
	id: number;
	itemId: number | null;
	fieldId: number | null;
	value: string | null;
	createdAt: number | string | null;
	updatedAt: number | string | null;
};

type RawListFieldValuesRow = {
	id: number;
	item_id: number | null;
	field_id: number | null;
	value: string | null;
	created_at: number | string | null;
	updated_at: number | string | null;
};

export function listFieldValues(
	d1: D1Database,
	args: ListFieldValuesParams,
): Query<D1Result<ListFieldValuesRow>> {
	const ps = d1.prepare(listFieldValuesQuery).bind(args.itemId);
	return {
		then(
			onFulfilled?: (value: D1Result<ListFieldValuesRow>) => void,
			onRejected?: (reason?: any) => void,
		) {
			ps.all<RawListFieldValuesRow>()
				.then((r: D1Result<RawListFieldValuesRow>) => {
					return {
						...r,
						results: r.results.map((raw: RawListFieldValuesRow) => {
							return {
								id: raw.id,
								itemId: raw.item_id,
								fieldId: raw.field_id,
								value: raw.value,
								createdAt: raw.created_at,
								updatedAt: raw.updated_at,
							};
						}),
					};
				})
				.then(onFulfilled)
				.catch(onRejected);
		},
		batch() {
			return ps;
		},
	};
}

const updateFieldValueQuery = `-- name: UpdateFieldValue :one
UPDATE field_values
SET value = ?1, updated_at = CURRENT_TIMESTAMP
WHERE id = ?2
RETURNING id, item_id, field_id, value, created_at, updated_at`;

export type UpdateFieldValueParams = {
	value: string | null;
	id: number;
};

export type UpdateFieldValueRow = {
	id: number;
	itemId: number | null;
	fieldId: number | null;
	value: string | null;
	createdAt: number | string | null;
	updatedAt: number | string | null;
};

type RawUpdateFieldValueRow = {
	id: number;
	item_id: number | null;
	field_id: number | null;
	value: string | null;
	created_at: number | string | null;
	updated_at: number | string | null;
};

export function updateFieldValue(
	d1: D1Database,
	args: UpdateFieldValueParams,
): Query<UpdateFieldValueRow | null> {
	const ps = d1.prepare(updateFieldValueQuery).bind(args.value, args.id);
	return {
		then(
			onFulfilled?: (value: UpdateFieldValueRow | null) => void,
			onRejected?: (reason?: any) => void,
		) {
			ps.first<RawUpdateFieldValueRow | null>()
				.then((raw: RawUpdateFieldValueRow | null) =>
					raw
						? {
								id: raw.id,
								itemId: raw.item_id,
								fieldId: raw.field_id,
								value: raw.value,
								createdAt: raw.created_at,
								updatedAt: raw.updated_at,
							}
						: null,
				)
				.then(onFulfilled)
				.catch(onRejected);
		},
		batch() {
			return ps;
		},
	};
}

const deleteFieldValueQuery = `-- name: DeleteFieldValue :exec
DELETE FROM field_values
WHERE id = ?1`;

export type DeleteFieldValueParams = {
	id: number;
};

export function deleteFieldValue(
	d1: D1Database,
	args: DeleteFieldValueParams,
): Query<D1Result> {
	const ps = d1.prepare(deleteFieldValueQuery).bind(args.id);
	return {
		then(
			onFulfilled?: (value: D1Result) => void,
			onRejected?: (reason?: any) => void,
		) {
			ps.run().then(onFulfilled).catch(onRejected);
		},
		batch() {
			return ps;
		},
	};
}

const createFieldQuery = `-- name: CreateField :one
INSERT INTO fields (collection_id, name, type, required)
VALUES (?1, ?2, ?3, ?4)
RETURNING id, collection_id, name, type, required, created_at, updated_at`;

export type CreateFieldParams = {
	collectionId: number | null;
	name: number | string;
	type: number | string;
	required: number | string | null;
};

export type CreateFieldRow = {
	id: number;
	collectionId: number | null;
	name: number | string;
	type: number | string;
	required: number | string | null;
	createdAt: number | string | null;
	updatedAt: number | string | null;
};

type RawCreateFieldRow = {
	id: number;
	collection_id: number | null;
	name: number | string;
	type: number | string;
	required: number | string | null;
	created_at: number | string | null;
	updated_at: number | string | null;
};

export function createField(
	d1: D1Database,
	args: CreateFieldParams,
): Query<CreateFieldRow | null> {
	const ps = d1
		.prepare(createFieldQuery)
		.bind(args.collectionId, args.name, args.type, args.required);
	return {
		then(
			onFulfilled?: (value: CreateFieldRow | null) => void,
			onRejected?: (reason?: any) => void,
		) {
			ps.first<RawCreateFieldRow | null>()
				.then((raw: RawCreateFieldRow | null) =>
					raw
						? {
								id: raw.id,
								collectionId: raw.collection_id,
								name: raw.name,
								type: raw.type,
								required: raw.required,
								createdAt: raw.created_at,
								updatedAt: raw.updated_at,
							}
						: null,
				)
				.then(onFulfilled)
				.catch(onRejected);
		},
		batch() {
			return ps;
		},
	};
}

const getFieldQuery = `-- name: GetField :one
SELECT id, collection_id, name, type, required, created_at, updated_at
FROM fields
WHERE id = ?1 LIMIT 1`;

export type GetFieldParams = {
	id: number;
};

export type GetFieldRow = {
	id: number;
	collectionId: number | null;
	name: number | string;
	type: number | string;
	required: number | string | null;
	createdAt: number | string | null;
	updatedAt: number | string | null;
};

type RawGetFieldRow = {
	id: number;
	collection_id: number | null;
	name: number | string;
	type: number | string;
	required: number | string | null;
	created_at: number | string | null;
	updated_at: number | string | null;
};

export function getField(
	d1: D1Database,
	args: GetFieldParams,
): Query<GetFieldRow | null> {
	const ps = d1.prepare(getFieldQuery).bind(args.id);
	return {
		then(
			onFulfilled?: (value: GetFieldRow | null) => void,
			onRejected?: (reason?: any) => void,
		) {
			ps.first<RawGetFieldRow | null>()
				.then((raw: RawGetFieldRow | null) =>
					raw
						? {
								id: raw.id,
								collectionId: raw.collection_id,
								name: raw.name,
								type: raw.type,
								required: raw.required,
								createdAt: raw.created_at,
								updatedAt: raw.updated_at,
							}
						: null,
				)
				.then(onFulfilled)
				.catch(onRejected);
		},
		batch() {
			return ps;
		},
	};
}

const listFieldsQuery = `-- name: ListFields :many
SELECT id, collection_id, name, type, required, created_at, updated_at
FROM fields
WHERE collection_id = ?1
ORDER BY id`;

export type ListFieldsParams = {
	collectionId: number | null;
};

export type ListFieldsRow = {
	id: number;
	collectionId: number | null;
	name: number | string;
	type: number | string;
	required: number | string | null;
	createdAt: number | string | null;
	updatedAt: number | string | null;
};

type RawListFieldsRow = {
	id: number;
	collection_id: number | null;
	name: number | string;
	type: number | string;
	required: number | string | null;
	created_at: number | string | null;
	updated_at: number | string | null;
};

export function listFields(
	d1: D1Database,
	args: ListFieldsParams,
): Query<D1Result<ListFieldsRow>> {
	const ps = d1.prepare(listFieldsQuery).bind(args.collectionId);
	return {
		then(
			onFulfilled?: (value: D1Result<ListFieldsRow>) => void,
			onRejected?: (reason?: any) => void,
		) {
			ps.all<RawListFieldsRow>()
				.then((r: D1Result<RawListFieldsRow>) => {
					return {
						...r,
						results: r.results.map((raw: RawListFieldsRow) => {
							return {
								id: raw.id,
								collectionId: raw.collection_id,
								name: raw.name,
								type: raw.type,
								required: raw.required,
								createdAt: raw.created_at,
								updatedAt: raw.updated_at,
							};
						}),
					};
				})
				.then(onFulfilled)
				.catch(onRejected);
		},
		batch() {
			return ps;
		},
	};
}

const updateFieldQuery = `-- name: UpdateField :one
UPDATE fields
SET name = COALESCE(?1, name), type = COALESCE(?2, type), required = COALESCE(?3, required), updated_at = CURRENT_TIMESTAMP
WHERE id = ?4
RETURNING id, collection_id, name, type, required, created_at, updated_at`;

export type UpdateFieldParams = {
	name: number | string;
	type: number | string;
	required: number | string | null;
	id: number;
};

export type UpdateFieldRow = {
	id: number;
	collectionId: number | null;
	name: number | string;
	type: number | string;
	required: number | string | null;
	createdAt: number | string | null;
	updatedAt: number | string | null;
};

type RawUpdateFieldRow = {
	id: number;
	collection_id: number | null;
	name: number | string;
	type: number | string;
	required: number | string | null;
	created_at: number | string | null;
	updated_at: number | string | null;
};

export function updateField(
	d1: D1Database,
	args: UpdateFieldParams,
): Query<UpdateFieldRow | null> {
	const ps = d1
		.prepare(updateFieldQuery)
		.bind(args.name, args.type, args.required, args.id);
	return {
		then(
			onFulfilled?: (value: UpdateFieldRow | null) => void,
			onRejected?: (reason?: any) => void,
		) {
			ps.first<RawUpdateFieldRow | null>()
				.then((raw: RawUpdateFieldRow | null) =>
					raw
						? {
								id: raw.id,
								collectionId: raw.collection_id,
								name: raw.name,
								type: raw.type,
								required: raw.required,
								createdAt: raw.created_at,
								updatedAt: raw.updated_at,
							}
						: null,
				)
				.then(onFulfilled)
				.catch(onRejected);
		},
		batch() {
			return ps;
		},
	};
}

const deleteFieldQuery = `-- name: DeleteField :exec
DELETE FROM fields
WHERE id = ?1`;

export type DeleteFieldParams = {
	id: number;
};

export function deleteField(
	d1: D1Database,
	args: DeleteFieldParams,
): Query<D1Result> {
	const ps = d1.prepare(deleteFieldQuery).bind(args.id);
	return {
		then(
			onFulfilled?: (value: D1Result) => void,
			onRejected?: (reason?: any) => void,
		) {
			ps.run().then(onFulfilled).catch(onRejected);
		},
		batch() {
			return ps;
		},
	};
}

const createItemQuery = `-- name: CreateItem :one
INSERT INTO items (collection_id, status)
VALUES (?1, ?2)
RETURNING id, collection_id, status, created_at, updated_at`;

export type CreateItemParams = {
	collectionId: number | null;
	status: number | string | null;
};

export type CreateItemRow = {
	id: number;
	collectionId: number | null;
	status: number | string | null;
	createdAt: number | string | null;
	updatedAt: number | string | null;
};

type RawCreateItemRow = {
	id: number;
	collection_id: number | null;
	status: number | string | null;
	created_at: number | string | null;
	updated_at: number | string | null;
};

export function createItem(
	d1: D1Database,
	args: CreateItemParams,
): Query<CreateItemRow | null> {
	const ps = d1.prepare(createItemQuery).bind(args.collectionId, args.status);
	return {
		then(
			onFulfilled?: (value: CreateItemRow | null) => void,
			onRejected?: (reason?: any) => void,
		) {
			ps.first<RawCreateItemRow | null>()
				.then((raw: RawCreateItemRow | null) =>
					raw
						? {
								id: raw.id,
								collectionId: raw.collection_id,
								status: raw.status,
								createdAt: raw.created_at,
								updatedAt: raw.updated_at,
							}
						: null,
				)
				.then(onFulfilled)
				.catch(onRejected);
		},
		batch() {
			return ps;
		},
	};
}

const getItemQuery = `-- name: GetItem :one
SELECT id, collection_id, status, created_at, updated_at FROM items
WHERE id = ?1 LIMIT 1`;

export type GetItemParams = {
	id: number;
};

export type GetItemRow = {
	id: number;
	collectionId: number | null;
	status: number | string | null;
	createdAt: number | string | null;
	updatedAt: number | string | null;
};

type RawGetItemRow = {
	id: number;
	collection_id: number | null;
	status: number | string | null;
	created_at: number | string | null;
	updated_at: number | string | null;
};

export function getItem(
	d1: D1Database,
	args: GetItemParams,
): Query<GetItemRow | null> {
	const ps = d1.prepare(getItemQuery).bind(args.id);
	return {
		then(
			onFulfilled?: (value: GetItemRow | null) => void,
			onRejected?: (reason?: any) => void,
		) {
			ps.first<RawGetItemRow | null>()
				.then((raw: RawGetItemRow | null) =>
					raw
						? {
								id: raw.id,
								collectionId: raw.collection_id,
								status: raw.status,
								createdAt: raw.created_at,
								updatedAt: raw.updated_at,
							}
						: null,
				)
				.then(onFulfilled)
				.catch(onRejected);
		},
		batch() {
			return ps;
		},
	};
}

const listItemsQuery = `-- name: ListItems :many
SELECT id, collection_id, status, created_at, updated_at FROM items
WHERE collection_id = ?1 AND (status = ?2 OR ?2 IS NULL)
ORDER BY id`;

export type ListItemsParams = {
	collectionId: number | null;
	status: number | string | null;
};

export type ListItemsRow = {
	id: number;
	collectionId: number | null;
	status: number | string | null;
	createdAt: number | string | null;
	updatedAt: number | string | null;
};

type RawListItemsRow = {
	id: number;
	collection_id: number | null;
	status: number | string | null;
	created_at: number | string | null;
	updated_at: number | string | null;
};

export function listItems(
	d1: D1Database,
	args: ListItemsParams,
): Query<D1Result<ListItemsRow>> {
	const ps = d1.prepare(listItemsQuery).bind(args.collectionId, args.status);
	return {
		then(
			onFulfilled?: (value: D1Result<ListItemsRow>) => void,
			onRejected?: (reason?: any) => void,
		) {
			ps.all<RawListItemsRow>()
				.then((r: D1Result<RawListItemsRow>) => {
					return {
						...r,
						results: r.results.map((raw: RawListItemsRow) => {
							return {
								id: raw.id,
								collectionId: raw.collection_id,
								status: raw.status,
								createdAt: raw.created_at,
								updatedAt: raw.updated_at,
							};
						}),
					};
				})
				.then(onFulfilled)
				.catch(onRejected);
		},
		batch() {
			return ps;
		},
	};
}

const updateItemQuery = `-- name: UpdateItem :one
UPDATE items
SET status = ?1, updated_at = CURRENT_TIMESTAMP
WHERE id = ?2
RETURNING id, collection_id, status, created_at, updated_at`;

export type UpdateItemParams = {
	status: number | string | null;
	id: number;
};

export type UpdateItemRow = {
	id: number;
	collectionId: number | null;
	status: number | string | null;
	createdAt: number | string | null;
	updatedAt: number | string | null;
};

type RawUpdateItemRow = {
	id: number;
	collection_id: number | null;
	status: number | string | null;
	created_at: number | string | null;
	updated_at: number | string | null;
};

export function updateItem(
	d1: D1Database,
	args: UpdateItemParams,
): Query<UpdateItemRow | null> {
	const ps = d1.prepare(updateItemQuery).bind(args.status, args.id);
	return {
		then(
			onFulfilled?: (value: UpdateItemRow | null) => void,
			onRejected?: (reason?: any) => void,
		) {
			ps.first<RawUpdateItemRow | null>()
				.then((raw: RawUpdateItemRow | null) =>
					raw
						? {
								id: raw.id,
								collectionId: raw.collection_id,
								status: raw.status,
								createdAt: raw.created_at,
								updatedAt: raw.updated_at,
							}
						: null,
				)
				.then(onFulfilled)
				.catch(onRejected);
		},
		batch() {
			return ps;
		},
	};
}

const deleteItemQuery = `-- name: DeleteItem :exec
DELETE FROM items
WHERE id = ?1`;

export type DeleteItemParams = {
	id: number;
};

export function deleteItem(
	d1: D1Database,
	args: DeleteItemParams,
): Query<D1Result> {
	const ps = d1.prepare(deleteItemQuery).bind(args.id);
	return {
		then(
			onFulfilled?: (value: D1Result) => void,
			onRejected?: (reason?: any) => void,
		) {
			ps.run().then(onFulfilled).catch(onRejected);
		},
		batch() {
			return ps;
		},
	};
}

const getFieldValuesForItemQuery = `-- name: GetFieldValuesForItem :many
SELECT id, item_id, field_id, value, created_at, updated_at FROM field_values
WHERE item_id = ?1`;

export type GetFieldValuesForItemParams = {
	itemId: number | null;
};

export type GetFieldValuesForItemRow = {
	id: number;
	itemId: number | null;
	fieldId: number | null;
	value: string | null;
	createdAt: number | string | null;
	updatedAt: number | string | null;
};

type RawGetFieldValuesForItemRow = {
	id: number;
	item_id: number | null;
	field_id: number | null;
	value: string | null;
	created_at: number | string | null;
	updated_at: number | string | null;
};

export function getFieldValuesForItem(
	d1: D1Database,
	args: GetFieldValuesForItemParams,
): Query<D1Result<GetFieldValuesForItemRow>> {
	const ps = d1.prepare(getFieldValuesForItemQuery).bind(args.itemId);
	return {
		then(
			onFulfilled?: (value: D1Result<GetFieldValuesForItemRow>) => void,
			onRejected?: (reason?: any) => void,
		) {
			ps.all<RawGetFieldValuesForItemRow>()
				.then((r: D1Result<RawGetFieldValuesForItemRow>) => {
					return {
						...r,
						results: r.results.map((raw: RawGetFieldValuesForItemRow) => {
							return {
								id: raw.id,
								itemId: raw.item_id,
								fieldId: raw.field_id,
								value: raw.value,
								createdAt: raw.created_at,
								updatedAt: raw.updated_at,
							};
						}),
					};
				})
				.then(onFulfilled)
				.catch(onRejected);
		},
		batch() {
			return ps;
		},
	};
}

const getFieldsForCollectionQuery = `-- name: GetFieldsForCollection :many
SELECT id, collection_id, name, type, required, created_at, updated_at FROM fields
WHERE collection_id = ?1`;

export type GetFieldsForCollectionParams = {
	collectionId: number | null;
};

export type GetFieldsForCollectionRow = {
	id: number;
	collectionId: number | null;
	name: number | string;
	type: number | string;
	required: number | string | null;
	createdAt: number | string | null;
	updatedAt: number | string | null;
};

type RawGetFieldsForCollectionRow = {
	id: number;
	collection_id: number | null;
	name: number | string;
	type: number | string;
	required: number | string | null;
	created_at: number | string | null;
	updated_at: number | string | null;
};

export function getFieldsForCollection(
	d1: D1Database,
	args: GetFieldsForCollectionParams,
): Query<D1Result<GetFieldsForCollectionRow>> {
	const ps = d1.prepare(getFieldsForCollectionQuery).bind(args.collectionId);
	return {
		then(
			onFulfilled?: (value: D1Result<GetFieldsForCollectionRow>) => void,
			onRejected?: (reason?: any) => void,
		) {
			ps.all<RawGetFieldsForCollectionRow>()
				.then((r: D1Result<RawGetFieldsForCollectionRow>) => {
					return {
						...r,
						results: r.results.map((raw: RawGetFieldsForCollectionRow) => {
							return {
								id: raw.id,
								collectionId: raw.collection_id,
								name: raw.name,
								type: raw.type,
								required: raw.required,
								createdAt: raw.created_at,
								updatedAt: raw.updated_at,
							};
						}),
					};
				})
				.then(onFulfilled)
				.catch(onRejected);
		},
		batch() {
			return ps;
		},
	};
}

const getItemByCollectionAndIdQuery = `-- name: GetItemByCollectionAndId :one
SELECT id, collection_id, status, created_at, updated_at FROM items
WHERE collection_id = ?1 AND id = ?2 LIMIT 1`;

export type GetItemByCollectionAndIdParams = {
	collectionId: number | null;
	id: number;
};

export type GetItemByCollectionAndIdRow = {
	id: number;
	collectionId: number | null;
	status: number | string | null;
	createdAt: number | string | null;
	updatedAt: number | string | null;
};

type RawGetItemByCollectionAndIdRow = {
	id: number;
	collection_id: number | null;
	status: number | string | null;
	created_at: number | string | null;
	updated_at: number | string | null;
};

export function getItemByCollectionAndId(
	d1: D1Database,
	args: GetItemByCollectionAndIdParams,
): Query<GetItemByCollectionAndIdRow | null> {
	const ps = d1
		.prepare(getItemByCollectionAndIdQuery)
		.bind(args.collectionId, args.id);
	return {
		then(
			onFulfilled?: (value: GetItemByCollectionAndIdRow | null) => void,
			onRejected?: (reason?: any) => void,
		) {
			ps.first<RawGetItemByCollectionAndIdRow | null>()
				.then((raw: RawGetItemByCollectionAndIdRow | null) =>
					raw
						? {
								id: raw.id,
								collectionId: raw.collection_id,
								status: raw.status,
								createdAt: raw.created_at,
								updatedAt: raw.updated_at,
							}
						: null,
				)
				.then(onFulfilled)
				.catch(onRejected);
		},
		batch() {
			return ps;
		},
	};
}

const listItemsForCollectionQuery = `-- name: ListItemsForCollection :many
SELECT id, collection_id, status, created_at, updated_at FROM items
WHERE collection_id = ?1
ORDER BY created_at DESC
LIMIT ?3 OFFSET ?2`;

export type ListItemsForCollectionParams = {
	collectionId: number | null;
	offset: number;
	limit: number;
};

export type ListItemsForCollectionRow = {
	id: number;
	collectionId: number | null;
	status: number | string | null;
	createdAt: number | string | null;
	updatedAt: number | string | null;
};

type RawListItemsForCollectionRow = {
	id: number;
	collection_id: number | null;
	status: number | string | null;
	created_at: number | string | null;
	updated_at: number | string | null;
};

export function listItemsForCollection(
	d1: D1Database,
	args: ListItemsForCollectionParams,
): Query<D1Result<ListItemsForCollectionRow>> {
	const ps = d1
		.prepare(listItemsForCollectionQuery)
		.bind(args.collectionId, args.offset, args.limit);
	return {
		then(
			onFulfilled?: (value: D1Result<ListItemsForCollectionRow>) => void,
			onRejected?: (reason?: any) => void,
		) {
			ps.all<RawListItemsForCollectionRow>()
				.then((r: D1Result<RawListItemsForCollectionRow>) => {
					return {
						...r,
						results: r.results.map((raw: RawListItemsForCollectionRow) => {
							return {
								id: raw.id,
								collectionId: raw.collection_id,
								status: raw.status,
								createdAt: raw.created_at,
								updatedAt: raw.updated_at,
							};
						}),
					};
				})
				.then(onFulfilled)
				.catch(onRejected);
		},
		batch() {
			return ps;
		},
	};
}

const countItemsForCollectionQuery = `-- name: CountItemsForCollection :one
SELECT COUNT(*) AS count FROM items
WHERE collection_id = ?1`;

export type CountItemsForCollectionParams = {
	collectionId: number | null;
};

export type CountItemsForCollectionRow = {
	count: number;
};

export function countItemsForCollection(
	d1: D1Database,
	args: CountItemsForCollectionParams,
): Query<CountItemsForCollectionRow | null> {
	const ps = d1.prepare(countItemsForCollectionQuery).bind(args.collectionId);
	return {
		then(
			onFulfilled?: (value: CountItemsForCollectionRow | null) => void,
			onRejected?: (reason?: any) => void,
		) {
			ps.first<CountItemsForCollectionRow | null>()
				.then(onFulfilled)
				.catch(onRejected);
		},
		batch() {
			return ps;
		},
	};
}

const createRoleQuery = `-- name: CreateRole :one
INSERT INTO roles (name, description)
VALUES (?1, ?2)
RETURNING id, name, description, created_at, updated_at`;

export type CreateRoleParams = {
	name: number | string;
	description: string | null;
};

export type CreateRoleRow = {
	id: number;
	name: number | string;
	description: string | null;
	createdAt: number | string | null;
	updatedAt: number | string | null;
};

type RawCreateRoleRow = {
	id: number;
	name: number | string;
	description: string | null;
	created_at: number | string | null;
	updated_at: number | string | null;
};

export function createRole(
	d1: D1Database,
	args: CreateRoleParams,
): Query<CreateRoleRow | null> {
	const ps = d1.prepare(createRoleQuery).bind(args.name, args.description);
	return {
		then(
			onFulfilled?: (value: CreateRoleRow | null) => void,
			onRejected?: (reason?: any) => void,
		) {
			ps.first<RawCreateRoleRow | null>()
				.then((raw: RawCreateRoleRow | null) =>
					raw
						? {
								id: raw.id,
								name: raw.name,
								description: raw.description,
								createdAt: raw.created_at,
								updatedAt: raw.updated_at,
							}
						: null,
				)
				.then(onFulfilled)
				.catch(onRejected);
		},
		batch() {
			return ps;
		},
	};
}

const getRoleQuery = `-- name: GetRole :one
SELECT id, name, description, created_at, updated_at FROM roles
WHERE id = ?1 LIMIT 1`;

export type GetRoleParams = {
	id: number;
};

export type GetRoleRow = {
	id: number;
	name: number | string;
	description: string | null;
	createdAt: number | string | null;
	updatedAt: number | string | null;
};

type RawGetRoleRow = {
	id: number;
	name: number | string;
	description: string | null;
	created_at: number | string | null;
	updated_at: number | string | null;
};

export function getRole(
	d1: D1Database,
	args: GetRoleParams,
): Query<GetRoleRow | null> {
	const ps = d1.prepare(getRoleQuery).bind(args.id);
	return {
		then(
			onFulfilled?: (value: GetRoleRow | null) => void,
			onRejected?: (reason?: any) => void,
		) {
			ps.first<RawGetRoleRow | null>()
				.then((raw: RawGetRoleRow | null) =>
					raw
						? {
								id: raw.id,
								name: raw.name,
								description: raw.description,
								createdAt: raw.created_at,
								updatedAt: raw.updated_at,
							}
						: null,
				)
				.then(onFulfilled)
				.catch(onRejected);
		},
		batch() {
			return ps;
		},
	};
}

const listRolesQuery = `-- name: ListRoles :many
SELECT id, name, description, created_at, updated_at FROM roles`;

export type ListRolesRow = {
	id: number;
	name: number | string;
	description: string | null;
	createdAt: number | string | null;
	updatedAt: number | string | null;
};

type RawListRolesRow = {
	id: number;
	name: number | string;
	description: string | null;
	created_at: number | string | null;
	updated_at: number | string | null;
};

export function listRoles(d1: D1Database): Query<D1Result<ListRolesRow>> {
	const ps = d1.prepare(listRolesQuery);
	return {
		then(
			onFulfilled?: (value: D1Result<ListRolesRow>) => void,
			onRejected?: (reason?: any) => void,
		) {
			ps.all<RawListRolesRow>()
				.then((r: D1Result<RawListRolesRow>) => {
					return {
						...r,
						results: r.results.map((raw: RawListRolesRow) => {
							return {
								id: raw.id,
								name: raw.name,
								description: raw.description,
								createdAt: raw.created_at,
								updatedAt: raw.updated_at,
							};
						}),
					};
				})
				.then(onFulfilled)
				.catch(onRejected);
		},
		batch() {
			return ps;
		},
	};
}

const updateRoleQuery = `-- name: UpdateRole :one
UPDATE roles
SET name = ?1, description = ?2, updated_at = CURRENT_TIMESTAMP
WHERE id = ?3
RETURNING id, name, description, created_at, updated_at`;

export type UpdateRoleParams = {
	name: number | string;
	description: string | null;
	id: number;
};

export type UpdateRoleRow = {
	id: number;
	name: number | string;
	description: string | null;
	createdAt: number | string | null;
	updatedAt: number | string | null;
};

type RawUpdateRoleRow = {
	id: number;
	name: number | string;
	description: string | null;
	created_at: number | string | null;
	updated_at: number | string | null;
};

export function updateRole(
	d1: D1Database,
	args: UpdateRoleParams,
): Query<UpdateRoleRow | null> {
	const ps = d1
		.prepare(updateRoleQuery)
		.bind(args.name, args.description, args.id);
	return {
		then(
			onFulfilled?: (value: UpdateRoleRow | null) => void,
			onRejected?: (reason?: any) => void,
		) {
			ps.first<RawUpdateRoleRow | null>()
				.then((raw: RawUpdateRoleRow | null) =>
					raw
						? {
								id: raw.id,
								name: raw.name,
								description: raw.description,
								createdAt: raw.created_at,
								updatedAt: raw.updated_at,
							}
						: null,
				)
				.then(onFulfilled)
				.catch(onRejected);
		},
		batch() {
			return ps;
		},
	};
}

const deleteRoleQuery = `-- name: DeleteRole :exec
DELETE FROM roles WHERE id = ?1`;

export type DeleteRoleParams = {
	id: number;
};

export function deleteRole(
	d1: D1Database,
	args: DeleteRoleParams,
): Query<D1Result> {
	const ps = d1.prepare(deleteRoleQuery).bind(args.id);
	return {
		then(
			onFulfilled?: (value: D1Result) => void,
			onRejected?: (reason?: any) => void,
		) {
			ps.run().then(onFulfilled).catch(onRejected);
		},
		batch() {
			return ps;
		},
	};
}

const getUserRolesQuery = `-- name: GetUserRoles :many
SELECT r.id, r.name, r.description, r.created_at, r.updated_at FROM roles r
JOIN user_roles ur ON r.id = ur.role_id
WHERE ur.user_id = ?1`;

export type GetUserRolesParams = {
	userId: number | null;
};

export type GetUserRolesRow = {
	id: number;
	name: number | string;
	description: string | null;
	createdAt: number | string | null;
	updatedAt: number | string | null;
};

type RawGetUserRolesRow = {
	id: number;
	name: number | string;
	description: string | null;
	created_at: number | string | null;
	updated_at: number | string | null;
};

export function getUserRoles(
	d1: D1Database,
	args: GetUserRolesParams,
): Query<D1Result<GetUserRolesRow>> {
	const ps = d1.prepare(getUserRolesQuery).bind(args.userId);
	return {
		then(
			onFulfilled?: (value: D1Result<GetUserRolesRow>) => void,
			onRejected?: (reason?: any) => void,
		) {
			ps.all<RawGetUserRolesRow>()
				.then((r: D1Result<RawGetUserRolesRow>) => {
					return {
						...r,
						results: r.results.map((raw: RawGetUserRolesRow) => {
							return {
								id: raw.id,
								name: raw.name,
								description: raw.description,
								createdAt: raw.created_at,
								updatedAt: raw.updated_at,
							};
						}),
					};
				})
				.then(onFulfilled)
				.catch(onRejected);
		},
		batch() {
			return ps;
		},
	};
}

const assignRoleToUserQuery = `-- name: AssignRoleToUser :one
INSERT INTO user_roles (user_id, role_id)
VALUES (?1, ?2)
RETURNING id, user_id, role_id, created_at, updated_at`;

export type AssignRoleToUserParams = {
	userId: number | null;
	roleId: number | null;
};

export type AssignRoleToUserRow = {
	id: number;
	userId: number | null;
	roleId: number | null;
	createdAt: number | string | null;
	updatedAt: number | string | null;
};

type RawAssignRoleToUserRow = {
	id: number;
	user_id: number | null;
	role_id: number | null;
	created_at: number | string | null;
	updated_at: number | string | null;
};

export function assignRoleToUser(
	d1: D1Database,
	args: AssignRoleToUserParams,
): Query<AssignRoleToUserRow | null> {
	const ps = d1.prepare(assignRoleToUserQuery).bind(args.userId, args.roleId);
	return {
		then(
			onFulfilled?: (value: AssignRoleToUserRow | null) => void,
			onRejected?: (reason?: any) => void,
		) {
			ps.first<RawAssignRoleToUserRow | null>()
				.then((raw: RawAssignRoleToUserRow | null) =>
					raw
						? {
								id: raw.id,
								userId: raw.user_id,
								roleId: raw.role_id,
								createdAt: raw.created_at,
								updatedAt: raw.updated_at,
							}
						: null,
				)
				.then(onFulfilled)
				.catch(onRejected);
		},
		batch() {
			return ps;
		},
	};
}

const removeRoleFromUserQuery = `-- name: RemoveRoleFromUser :exec
DELETE FROM user_roles
WHERE user_id = ?1 AND role_id = ?2`;

export type RemoveRoleFromUserParams = {
	userId: number | null;
	roleId: number | null;
};

export function removeRoleFromUser(
	d1: D1Database,
	args: RemoveRoleFromUserParams,
): Query<D1Result> {
	const ps = d1.prepare(removeRoleFromUserQuery).bind(args.userId, args.roleId);
	return {
		then(
			onFulfilled?: (value: D1Result) => void,
			onRejected?: (reason?: any) => void,
		) {
			ps.run().then(onFulfilled).catch(onRejected);
		},
		batch() {
			return ps;
		},
	};
}

const createUserQuery = `-- name: CreateUser :one
INSERT INTO users (username, email, password_hash, is_admin)
VALUES (?1, ?2, ?3, ?4)
RETURNING id, username, email, password_hash, is_admin, created_at, updated_at`;

export type CreateUserParams = {
	username: number | string;
	email: number | string;
	passwordHash: number | string;
	isAdmin: number | string | null;
};

export type CreateUserRow = {
	id: number;
	username: number | string;
	email: number | string;
	passwordHash: number | string;
	isAdmin: number | string | null;
	createdAt: number | string | null;
	updatedAt: number | string | null;
};

type RawCreateUserRow = {
	id: number;
	username: number | string;
	email: number | string;
	password_hash: number | string;
	is_admin: number | string | null;
	created_at: number | string | null;
	updated_at: number | string | null;
};

export function createUser(
	d1: D1Database,
	args: CreateUserParams,
): Query<CreateUserRow | null> {
	const ps = d1
		.prepare(createUserQuery)
		.bind(args.username, args.email, args.passwordHash, args.isAdmin);
	return {
		then(
			onFulfilled?: (value: CreateUserRow | null) => void,
			onRejected?: (reason?: any) => void,
		) {
			ps.first<RawCreateUserRow | null>()
				.then((raw: RawCreateUserRow | null) =>
					raw
						? {
								id: raw.id,
								username: raw.username,
								email: raw.email,
								passwordHash: raw.password_hash,
								isAdmin: raw.is_admin,
								createdAt: raw.created_at,
								updatedAt: raw.updated_at,
							}
						: null,
				)
				.then(onFulfilled)
				.catch(onRejected);
		},
		batch() {
			return ps;
		},
	};
}

const getUserQuery = `-- name: GetUser :one
SELECT id, username, email, password_hash, is_admin, created_at, updated_at FROM users
WHERE id = ?1 LIMIT 1`;

export type GetUserParams = {
	id: number;
};

export type GetUserRow = {
	id: number;
	username: number | string;
	email: number | string;
	passwordHash: number | string;
	isAdmin: number | string | null;
	createdAt: number | string | null;
	updatedAt: number | string | null;
};

type RawGetUserRow = {
	id: number;
	username: number | string;
	email: number | string;
	password_hash: number | string;
	is_admin: number | string | null;
	created_at: number | string | null;
	updated_at: number | string | null;
};

export function getUser(
	d1: D1Database,
	args: GetUserParams,
): Query<GetUserRow | null> {
	const ps = d1.prepare(getUserQuery).bind(args.id);
	return {
		then(
			onFulfilled?: (value: GetUserRow | null) => void,
			onRejected?: (reason?: any) => void,
		) {
			ps.first<RawGetUserRow | null>()
				.then((raw: RawGetUserRow | null) =>
					raw
						? {
								id: raw.id,
								username: raw.username,
								email: raw.email,
								passwordHash: raw.password_hash,
								isAdmin: raw.is_admin,
								createdAt: raw.created_at,
								updatedAt: raw.updated_at,
							}
						: null,
				)
				.then(onFulfilled)
				.catch(onRejected);
		},
		batch() {
			return ps;
		},
	};
}

const listUsersQuery = `-- name: ListUsers :many
SELECT id, username, email, password_hash, is_admin, created_at, updated_at FROM users
ORDER BY id`;

export type ListUsersRow = {
	id: number;
	username: number | string;
	email: number | string;
	passwordHash: number | string;
	isAdmin: number | string | null;
	createdAt: number | string | null;
	updatedAt: number | string | null;
};

type RawListUsersRow = {
	id: number;
	username: number | string;
	email: number | string;
	password_hash: number | string;
	is_admin: number | string | null;
	created_at: number | string | null;
	updated_at: number | string | null;
};

export function listUsers(d1: D1Database): Query<D1Result<ListUsersRow>> {
	const ps = d1.prepare(listUsersQuery);
	return {
		then(
			onFulfilled?: (value: D1Result<ListUsersRow>) => void,
			onRejected?: (reason?: any) => void,
		) {
			ps.all<RawListUsersRow>()
				.then((r: D1Result<RawListUsersRow>) => {
					return {
						...r,
						results: r.results.map((raw: RawListUsersRow) => {
							return {
								id: raw.id,
								username: raw.username,
								email: raw.email,
								passwordHash: raw.password_hash,
								isAdmin: raw.is_admin,
								createdAt: raw.created_at,
								updatedAt: raw.updated_at,
							};
						}),
					};
				})
				.then(onFulfilled)
				.catch(onRejected);
		},
		batch() {
			return ps;
		},
	};
}

const updateUserQuery = `-- name: UpdateUser :one
UPDATE users
SET username = COALESCE(?1, username),
    email = COALESCE(?2, email),
    is_admin = COALESCE(?3, is_admin),
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?4
RETURNING id, username, email, password_hash, is_admin, created_at, updated_at`;

export type UpdateUserParams = {
	username: number | string;
	email: number | string;
	isAdmin: number | string | null;
	id: number;
};

export type UpdateUserRow = {
	id: number;
	username: number | string;
	email: number | string;
	passwordHash: number | string;
	isAdmin: number | string | null;
	createdAt: number | string | null;
	updatedAt: number | string | null;
};

type RawUpdateUserRow = {
	id: number;
	username: number | string;
	email: number | string;
	password_hash: number | string;
	is_admin: number | string | null;
	created_at: number | string | null;
	updated_at: number | string | null;
};

export function updateUser(
	d1: D1Database,
	args: UpdateUserParams,
): Query<UpdateUserRow | null> {
	const ps = d1
		.prepare(updateUserQuery)
		.bind(args.username, args.email, args.isAdmin, args.id);
	return {
		then(
			onFulfilled?: (value: UpdateUserRow | null) => void,
			onRejected?: (reason?: any) => void,
		) {
			ps.first<RawUpdateUserRow | null>()
				.then((raw: RawUpdateUserRow | null) =>
					raw
						? {
								id: raw.id,
								username: raw.username,
								email: raw.email,
								passwordHash: raw.password_hash,
								isAdmin: raw.is_admin,
								createdAt: raw.created_at,
								updatedAt: raw.updated_at,
							}
						: null,
				)
				.then(onFulfilled)
				.catch(onRejected);
		},
		batch() {
			return ps;
		},
	};
}

const deleteUserQuery = `-- name: DeleteUser :exec
DELETE FROM users
WHERE id = ?1`;

export type DeleteUserParams = {
	id: number;
};

export function deleteUser(
	d1: D1Database,
	args: DeleteUserParams,
): Query<D1Result> {
	const ps = d1.prepare(deleteUserQuery).bind(args.id);
	return {
		then(
			onFulfilled?: (value: D1Result) => void,
			onRejected?: (reason?: any) => void,
		) {
			ps.run().then(onFulfilled).catch(onRejected);
		},
		batch() {
			return ps;
		},
	};
}

const getUserByEmailQuery = `-- name: GetUserByEmail :one
SELECT id, username, email, password_hash, is_admin, created_at, updated_at FROM users
WHERE email = ?1 LIMIT 1`;

export type GetUserByEmailParams = {
	email: number | string;
};

export type GetUserByEmailRow = {
	id: number;
	username: number | string;
	email: number | string;
	passwordHash: number | string;
	isAdmin: number | string | null;
	createdAt: number | string | null;
	updatedAt: number | string | null;
};

type RawGetUserByEmailRow = {
	id: number;
	username: number | string;
	email: number | string;
	password_hash: number | string;
	is_admin: number | string | null;
	created_at: number | string | null;
	updated_at: number | string | null;
};

export function getUserByEmail(
	d1: D1Database,
	args: GetUserByEmailParams,
): Query<GetUserByEmailRow | null> {
	const ps = d1.prepare(getUserByEmailQuery).bind(args.email);
	return {
		then(
			onFulfilled?: (value: GetUserByEmailRow | null) => void,
			onRejected?: (reason?: any) => void,
		) {
			ps.first<RawGetUserByEmailRow | null>()
				.then((raw: RawGetUserByEmailRow | null) =>
					raw
						? {
								id: raw.id,
								username: raw.username,
								email: raw.email,
								passwordHash: raw.password_hash,
								isAdmin: raw.is_admin,
								createdAt: raw.created_at,
								updatedAt: raw.updated_at,
							}
						: null,
				)
				.then(onFulfilled)
				.catch(onRejected);
		},
		batch() {
			return ps;
		},
	};
}

const updateUserPasswordQuery = `-- name: UpdateUserPassword :exec
UPDATE users
SET password_hash = ?1, updated_at = CURRENT_TIMESTAMP
WHERE id = ?2`;

export type UpdateUserPasswordParams = {
	passwordHash: number | string;
	id: number;
};

export function updateUserPassword(
	d1: D1Database,
	args: UpdateUserPasswordParams,
): Query<D1Result> {
	const ps = d1
		.prepare(updateUserPasswordQuery)
		.bind(args.passwordHash, args.id);
	return {
		then(
			onFulfilled?: (value: D1Result) => void,
			onRejected?: (reason?: any) => void,
		) {
			ps.run().then(onFulfilled).catch(onRejected);
		},
		batch() {
			return ps;
		},
	};
}
